There are four files that are related to product creation:
server.cjs, producform, productapi, products = 
When i press submit button in the form this error shows:

5 
        
        
        POST http://127.0.0.1:4000/api/products 500 (Internal Server Error)
createProduct @ productsAPI.ts:25
createNewProduct @ productform.tsx:95
handleSubmit @ productform.tsx:147
callCallback @ react-dom.development.js:4164
invokeGuardedCallbackDev @ react-dom.development.js:4213
invokeGuardedCallback @ react-dom.development.js:4277
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:4291
executeDispatch @ react-dom.development.js:9041
processDispatchQueueItemsInOrder @ react-dom.development.js:9073
processDispatchQueue @ react-dom.development.js:9086
dispatchEventsForPlugins @ react-dom.development.js:9097
eval @ react-dom.development.js:9288
batchedUpdates$1 @ react-dom.development.js:26140
batchedUpdates @ react-dom.development.js:3991
dispatchEventForPluginEventSystem @ react-dom.development.js:9287
dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay @ react-dom.development.js:6465
dispatchEvent @ react-dom.development.js:6457
dispatchDiscreteEvent @ react-dom.development.js:6430
client.js:1  Error creating product: Error: Network response was not ok
    at createProduct (productsAPI.ts:31:13)
console.error @ client.js:1
window.console.error @ next-dev.js:20
createProduct @ productsAPI.ts:38
await in createProduct (async)
createNewProduct @ productform.tsx:95
handleSubmit @ productform.tsx:147
callCallback @ react-dom.development.js:4164
invokeGuardedCallbackDev @ react-dom.development.js:4213
invokeGuardedCallback @ react-dom.development.js:4277
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:4291
executeDispatch @ react-dom.development.js:9041
processDispatchQueueItemsInOrder @ react-dom.development.js:9073
processDispatchQueue @ react-dom.development.js:9086
dispatchEventsForPlugins @ react-dom.development.js:9097
eval @ react-dom.development.js:9288
batchedUpdates$1 @ react-dom.development.js:26140
batchedUpdates @ react-dom.development.js:3991
dispatchEventForPluginEventSystem @ react-dom.development.js:9287
dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay @ react-dom.development.js:6465
dispatchEvent @ react-dom.development.js:6457
dispatchDiscreteEvent @ react-dom.development.js:6430
client.js:1  An error occurred while creating product: Error: Network response was not ok
    at createProduct (productsAPI.ts:31:13)
console.error @ client.js:1
window.console.error @ next-dev.js:20
eval @ productform.tsx:107
Promise.catch (async)
createNewProduct @ productform.tsx:106
handleSubmit @ productform.tsx:147
callCallback @ react-dom.development.js:4164
invokeGuardedCallbackDev @ react-dom.development.js:4213
invokeGuardedCallback @ react-dom.development.js:4277
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:4291
executeDispatch @ react-dom.development.js:9041
processDispatchQueueItemsInOrder @ react-dom.development.js:9073
processDispatchQueue @ react-dom.development.js:9086
dispatchEventsForPlugins @ react-dom.development.js:9097
eval @ react-dom.development.js:9288
batchedUpdates$1 @ react-dom.development.js:26140
batchedUpdates @ react-dom.development.js:3991
dispatchEventForPluginEventSystem @ react-dom.development.js:9287
dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay @ react-dom.development.js:6465
dispatchEvent @ react-dom.development.js:6457
dispatchDiscreteEvent @ react-dom.development.js:6430
agfa.jpeg:1 
        
        
        GET http://localhost:4000/agfa.jpeg 404 (Not Found)
Image (async)
commitMount @ react-dom.development.js:11038
commitLayoutEffectOnFiber @ react-dom.development.js:23407
commitLayoutMountEffects_complete @ react-dom.development.js:24688
commitLayoutEffects_begin @ react-dom.development.js:24674
commitLayoutEffects @ react-dom.development.js:24612
commitRootImpl @ react-dom.development.js:26823
commitRoot @ react-dom.development.js:26682
finishConcurrentRender @ react-dom.development.js:25981
performConcurrentWorkOnRoot @ react-dom.development.js:25809
workLoop @ scheduler.development.js:266
flushWork @ scheduler.development.js:239
performWorkUntilDeadline @ scheduler.development.js:533
blogimage1.jpeg:1 
        
        
        GET http://localhost:4000/blogimage1.jpeg 404 (Not Found)
Image (async)
commitMount @ react-dom.development.js:11038
commitLayoutEffectOnFiber @ react-dom.development.js:23407
commitLayoutMountEffects_complete @ react-dom.development.js:24688
commitLayoutEffects_begin @ react-dom.development.js:24674
commitLayoutEffects @ react-dom.development.js:24612
commitRootImpl @ react-dom.development.js:26823
commitRoot @ react-dom.development.js:26682
finishConcurrentRender @ react-dom.development.js:25981
performConcurrentWorkOnRoot @ react-dom.development.js:25809
workLoop @ scheduler.development.js:266
flushWork @ scheduler.development.js:239
performWorkUntilDeadline @ scheduler.development.js:533
products.tsx:131 Current products: []
products.tsx:132 Selected product: null
productform.tsx:37 {_id: '', name: 'sfsdf', model: 'sdfsdf', brand: 'sdf', location: 'sdf', …}
productsAPI.ts:5 Fetching products...
productsAPI.ts:11 Fetched products: []
products.tsx:46 Fetched products: []
products.tsx:131 Current products: []
products.tsx:132 Selected product: null

---------------------------------------------------------------
Here are the files:

// multer diskStorage for product images
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const tmpDir = `C:/ecommerce2/server/Images/Products/tmp`;
    cb(null, tmpDir);
  },
  filename: function (req, file, cb) {
    const { model, location, year, exposureCounter } = req.body;
    const currentDate = new Date();
    const hours = String(currentDate.getHours()).padStart(2, '0');
    const minutes = String(currentDate.getMinutes()).padStart(2, '0');
    const seconds = String(currentDate.getSeconds()).padStart(2, '0');
    const timestamp = `${hours}-${minutes}-${seconds}`;

    // Create the new filename
    const newFileName = `${model}-${year}-${location}-${exposureCounter}-${timestamp}.${file.originalname.split('.').pop()}`;

    cb(null, newFileName);
  },
});

const upload = multer({ storage: storage });

router.post('/upload', upload.array('file'), (req, res) => {
  const { model, location, year, price, name } = req.body;
  const currentDate = new Date();
  const day = String(currentDate.getDate()).padStart(2, '0');
  const month = String(currentDate.getMonth() + 1).padStart(2, '0'); // Months are zero-based
  const year2 = currentDate.getFullYear();
  const hours = String(currentDate.getHours()).padStart(2, '0');
  const minutes = String(currentDate.getMinutes()).padStart(2, '0');
  const seconds = String(currentDate.getSeconds()).padStart(2, '0');
  const timestamp = `${day}-${month}-${year2}-${hours}-${minutes}-${seconds}`;
  const newFolderName = `C:/ecommerce2/server/Images/Products/${name}-${model}-${location}-${year}-${price}-${timestamp}`;

  if (!fs.existsSync(newFolderName)) {
    fs.mkdirSync(newFolderName, { recursive: true });
  }

  req.files.forEach(file => {
    const tempPath = file.path;
    const targetPath = path.join(newFolderName, file.filename);
    
    fs.rename(tempPath, targetPath, err => {
      if (err) return res.status(500).send(err);
    });
  });

  res.send('Files moved successfully');
});

app.use(serve("C:/ecommerce2/server/Images/Blogs"));

app.use(cors());

mongoose.connect("mongodb://127.0.0.1:27017/ecommerce2", {});

module.exports.createProduct = async (product, image) => {
  try {
    const date = new Date();
    const year = date.getFullYear();
    const { model, location, price } = product;
    const folderName = `${model}-${location}-${year}-${price}-${timestamp}`;

    console.log("Creating product...");
    console.log("Folder Name:", folderName);

    // Create folder if it doesn't exist
    const response = await fetch(`${baseURL}/create-folder/${folderName}`, {
      method: "POST",
    });

    if (!response.ok) {
      throw new Error("Error creating folder");
    }

    console.log("Folder created:", folderName);

    // Prepare the form data
    const formData = new FormData();
    formData.append("data", JSON.stringify(product));
    
    if (image) {
      // Append image to form data with filename :image.jpg
      formData.append("image", image, `image.jpg`);

      // Upload image to server
      const uploadResponse = await fetch(
        `${baseURL}/upload-image/${folderName}`,
        {
          method: "POST",
          body: formData,
        }
      );

      if (!uploadResponse.ok) {
        throw new Error("Error uploading image");
      }

      console.log("Image uploaded successfully");
    }

    const createProductResponse = await fetch(`${baseURL}/add-product`, {
      method: "POST",
      body: formData,
    });

    if (!createProductResponse.ok) {
      throw new Error("Network response was not ok");
    }

    const createdProduct = await createProductResponse.json();
    console.log("Product created:", createdProduct);
    return createdProduct;
  } catch (error) {
    console.error("Error creating product:", error);
    throw error;
  }
};

// Product related routes

const productSchema = new mongoose.Schema({
  name: String,
  model: String,
  brand: String,
  description: String,
  location: String,
  year: Number,
  exposureCounter: Number,
  price: Number,
  imageUrl: String,
  imagePath: String,
});

= server.cjs,
const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();

  const productFormData = new FormData();
  Object.entries(formData).forEach(([key, value]) => {
    if (key === 'image' && value) {  
      let fileValue = value as File; // Type assertion here
      productFormData.append(key, fileValue, fileValue.name);
    } else {
      productFormData.append(key, value.toString());
    }
  });

  try {
    if (formData._id && formData._id !== "") { // check if _id is not empty string
      let imageFile = formData.image ? formData.image : new File([], "");  // Fallback
      await updateExistingProduct(formData._id, productFormData, imageFile);  
    } else {
      await createNewProduct(productFormData);
    }
    setSelectedProduct(null);
  } catch (error) {
    console.error('Error in form submission:', error);
  }
  return undefined; 
};
 = productform.tsx
type Product = {
  _id: string;
  name: string;
  model: string;
  brand: string;
  location: string;
  year: number;
  exposureCounter: number;
  price: number;
  description: string;
  imageUrl: string;
  imagePath: string;
  image?: File;
};

const Products: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [formData, setFormData] = useState<Product>({
    _id: "",
    name: "sfsdf",
    model: "sdfsdf",
    brand: "sdf",
    location: "sdf",
    year: new Date().getFullYear(),
    exposureCounter: 230,
    price: 230,
    description: "sdf",
    imageUrl: "",
    imagePath: "",
  });

  useEffect(() => {
    fetchProducts();
  }, []);

  const fetchProducts = async () => {
    try {
      const products = await fetchProductsAPI();
      setProducts(products);
      console.log("Fetched products:", products);
    } catch (error) {
      console.error("Error fetching products:", error);
    }
  };

  const handleProductEdit = (product: Product) => {
  setFormData(product);
  setSelectedProduct(product);
  console.log("Selected product for editing:", product);
};


  const handleProductUpdate = async (updatedProduct: Product) => {
    try {
      console.log("Updating product:", updatedProduct);

      const savedProduct = await updateProduct(
        updatedProduct._id,
        updatedProduct,
        updatedProduct.image
      );

      console.log("Product updated:", savedProduct);

      // Update the products state with the updated product
      setProducts(products.map((product) =>
        product._id === savedProduct._id ? savedProduct : product
      ));

      // Update form data
      setFormData(savedProduct);
    } catch (error) {
      console.error("Error updating product:", error);
    }
};

  const handleProductDelete = async (productId: string) => {
    try {
      const productToDelete = products.find((product) => product._id === productId);
      if (!productToDelete) throw new Error("Product not found");

      await deleteImage(productToDelete.imagePath);
      await deleteProduct(productId);

      setProducts(products.filter((product) => product._id !== productId));
      console.log("Product deleted:", productId);
    } catch (error) {
      console.error("Error deleting product:", error.message);
    }
  };

  const handleProductSubmit = async (product: Product) => {
  try {
    const productFormData = new FormData();
    Object.entries(product).forEach(([key, value]) => {
      if (key === 'image' && value instanceof File) {
        productFormData.append(key, value, value.name);
      } else {
        productFormData.append(key, value.toString());
      }
    });

    const createdProduct = await createProduct(productFormData); // Adjusted to include a single FormData argument
    setProducts([...products, createdProduct]);
    setSelectedProduct(null);
    setFormData({
      _id: "",
      name: "",
      model: "",
      brand: "",
      location: "",
      year: new Date().getFullYear(),
      exposureCounter: 0,
      price: 0,
      description: "",
      imageUrl: "",
      imagePath: "",
    });
    console.log("Product created:", createdProduct);
  } catch (error) {
    console.error("Error creating product:", error);
  }
};
= product.tsx
export const createProduct = async (productFormData: FormData) => {
  try {
    console.log('Creating product...');

    console.log('FormData:', [...productFormData.entries()]); // Log form data

    const response = await fetch(baseURL, {
      method: 'POST',
      body: productFormData,
    });

    if (!response.ok) {
      throw new Error('Network response was not ok');
    }

    const createdProduct = await response.json();
    console.log('Created product:', createdProduct);
    return createdProduct;
  } catch (error) {
    console.error('Error creating product:', error);
    throw error;
  }
};
= productsapi.ts
