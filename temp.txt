
// multer diskStorage for product images
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const tmpDir = `C:/ecommerce2/server/Images/Products/tmp`;
    cb(null, tmpDir);
  },
  filename: function (req, file, cb) {
    const { model, location, year, exposureCounter } = req.body;
    const currentDate = new Date();
    const hours = String(currentDate.getHours()).padStart(2, '0');
    const minutes = String(currentDate.getMinutes()).padStart(2, '0');
    const seconds = String(currentDate.getSeconds()).padStart(2, '0');
    const timestamp = `${hours}-${minutes}-${seconds}`;

    // Create the new filename
    const newFileName = `${model}-${year}-${location}-${exposureCounter}-${timestamp}.${file.originalname.split('.').pop()}`;

    cb(null, newFileName);
  },
});

const upload = multer({ storage: storage }).single('file');


router.post("/api/products", upload, async (ctx) => {

  const { model, location, year, price, name } = req.body;
  const currentDate = new Date();
  const day = String(currentDate.getDate()).padStart(2, '0');
  const month = String(currentDate.getMonth() + 1).padStart(2, '0'); // Months are zero-based
  const year2 = currentDate.getFullYear();
  const hours = String(currentDate.getHours()).padStart(2, '0');
  const minutes = String(currentDate.getMinutes()).padStart(2, '0');
  const seconds = String(currentDate.getSeconds()).padStart(2, '0');
  const timestamp = `${day}-${month}-${year2}-${hours}-${minutes}-${seconds}`;
  const newFolderName = `C:/ecommerce2/server/Images/Products/${name}-${model}-${location}-${year}-${price}-${timestamp}`;

  if (!fs.existsSync(newFolderName)) {
    fs.mkdirSync(newFolderName, { recursive: true });
  }

  req.files.forEach(file => {
    const tempPath = file.path;
    const targetPath = path.join(newFolderName, file.filename);
    
    fs.rename(tempPath, targetPath, err => {
      if (err) return res.status(500).send(err);
    });
  });

  res.send('Files moved successfully');
});

app.use(serve("C:/ecommerce2/server/Images/Blogs"));

app.use(cors());

mongoose.connect("mongodb://127.0.0.1:27017/ecommerce2", {});

module.exports.createProduct = async (product, image) => {
  try {
    const date = new Date();
    const year = date.getFullYear();
    const { model, location, price } = product;
    const folderName = `${model}-${location}-${year}-${price}-${timestamp}`;

    console.log("Creating product...");
    console.log("Folder Name:", folderName);

    // Create folder if it doesn't exist
    const response = await fetch(`${baseURL}/create-folder/${folderName}`, {
      method: "POST",
    });

    if (!response.ok) {
      throw new Error("Error creating folder");
    }

    console.log("Folder created:", folderName);

    // Prepare the form data
    const formData = new FormData();
    formData.append("data", JSON.stringify(product));
    
    if (image) {
      // Append image to form data with filename :image.jpg
      formData.append("image", image, `image.jpg`);

      // Upload image to server
      const uploadResponse = await fetch(
        `${baseURL}/upload-image/${folderName}`,
        {
          method: "POST",
          body: formData,
        }
      );

      if (!uploadResponse.ok) {
        throw new Error("Error uploading image");
      }

      console.log("Image uploaded successfully");
    }

    const createProductResponse = await fetch(`${baseURL}/add-product`, {
      method: "POST",
      body: formData,
    });

    if (!createProductResponse.ok) {
      throw new Error("Network response was not ok");
    }

    const createdProduct = await createProductResponse.json();
    console.log("Product created:", createdProduct);
    return createdProduct;
  } catch (error) {
    console.error("Error creating product:", error);
    throw error;
  }
};

// Product related routes

const productSchema = new mongoose.Schema({
  name: String,
  model: String,
  brand: String,
  description: String,
  location: String,
  year: Number,
  exposureCounter: Number,
  price: Number,
  imageUrl: String,
  imagePath: String,
});


const Product = mongoose.model("Product", productSchema);

router.get("/api/products", async (ctx) => {
  try {
    console.log("Received request for /api/products");
    const products = await Product.find();
    console.log("Fetched products:", products);
    ctx.body = products;
  } catch (err) {
    console.error('Error fetching products:', err);
    ctx.status = 500;
    ctx.body = { error: "An error occurred while fetching the products" };
  }
});

router.post("/api/products", upload, async (ctx) => {
  try {
    const file = ctx.request.file; // Access the uploaded file
    const { model, location, year, price, name, brand, description, exposureCounter } = ctx.request.body; // Access the form data

    // Create timestamp
    const currentDate = new Date();
    const day = String(currentDate.getDate()).padStart(2, '0');
    const month = String(currentDate.getMonth() + 1).padStart(2, '0');
    const year2 = currentDate.getFullYear();
    const hours = String(currentDate.getHours()).padStart(2, '0');
    const minutes = String(currentDate.getMinutes()).padStart(2, '0');
    const seconds = String(currentDate.getSeconds()).padStart(2, '0');
    const timestamp = `${day}-${month}-${year2}-${hours}-${minutes}-${seconds}`;

    // Create the product
    const product = await Product.create({
      name,
      model,
      brand,
      location,
      year: parseInt(year),
      exposureCounter: parseInt(exposureCounter),
      price: parseFloat(price),
      description,
      // The imageUrl and imagePath will be set later
    });

    const newFolderPath = `C:/ecommerce2/server/Images/Products/${product.name}-${product.model}-${product.location}-${product.year}-${product.price}-${timestamp}`;

    if (!fs.existsSync(newFolderPath)) {
      fs.mkdirSync(newFolderPath, { recursive: true });
    }

    // Move the files to the new directory and create image URLs
    const imagePaths = [];
    const imageURLs = [];
    ctx.request.files.forEach((file, index) => {
      const tempPath = file.path;
      const targetPath = path.join(newFolderPath, file.filename);
      fs.renameSync(tempPath, targetPath);
      
      imagePaths.push(targetPath);
      // Replace with the URL of your server
      imageURLs.push(`http://localhost:3000/Images/Products/${product.name}-${product.model}-${product.location}-${product.year}-${product.price}-${timestamp}/${file.filename}`);
    });

    // Update the product with the imageURLs and imagePaths
    product.imageUrl = imageURLs;
    product.imagePath = imagePaths;
    await product.save();

    // Return successful response
    ctx.status = 200;
    ctx.body = { message: "Product created and files uploaded successfully.", product };
  } catch (err) {
    console.error('General error:', err);
    ctx.status = 500;
    ctx.body = { error: "An error occurred while uploading the files or creating the product." };
  }
});

module.exports = router;


const uploadForUpdate = multer({ storage: storage });


// Use the refactored function inside the route
router.put("/api/products/:id", uploadForUpdate.single("image"), async (ctx) => {
  try {
    const id = ctx.params.id;
    const productData = ctx.request.body.data ? JSON.parse(ctx.request.body.data) : ctx.request.body;
    const image = ctx.request.file;

    const oldProduct = await Product.findById(id);
    if (!oldProduct) {
      ctx.status = 404;
      ctx.body = { error: "Product not found" };
      return;
    }

    const fieldsChanged = productData.name !== oldProduct.name || 
                      productData.model !== oldProduct.model ||
                      productData.location !== oldProduct.location ||
                      productData.year !== oldProduct.year ||
                      productData.price !== oldProduct.price ||
                      productData.exposureCounter !== oldProduct.exposureCounter;

    const timestamp = new Date().toISOString().replace(/:/g, "-").split('.')[0]; // remove milliseconds
    const newFolderPath = `C:/ecommerce2/server/Images/Products/${productData.name}-${productData.model}-${productData.location}-${productData.year}-${productData.price}-${timestamp}`;

    if (fieldsChanged) {
      const oldFolderPath = path.join(__dirname, "Images", "Products", oldProduct.imagePath);
      if (fs.existsSync(oldFolderPath)) {
        fs.renameSync(oldFolderPath, `${oldFolderPath}_old`);
      }
      if (!fs.existsSync(newFolderPath)) {
        fs.mkdirSync(newFolderPath, { recursive: true });
      }

      const newImagePath = path.join(__dirname, "Images", "Products", newFolderPath);
      if (image) {
        fs.copyFileSync(image.path, path.join(newImagePath, image.filename));
      } else if (fs.existsSync(path.join(`${oldFolderPath}_old`, oldProduct.imageUrl))) {
        fs.copyFileSync(path.join(`${oldFolderPath}_old`, oldProduct.imageUrl), path.join(newFolderPath, oldProduct.imageUrl));
      }
    }

    const imagePath = fieldsChanged ? `${productData.name}-${productData.model}-${productData.location}-${productData.year}-${productData.price}-${timestamp}` : oldProduct.imagePath;
    const imageUrl = image ? `${imagePath}/${image.filename}` : oldProduct.imageUrl;

    const updateObj = {
      ...productData,
      imagePath: imagePath,
      imageUrl: imageUrl,
    };

    const updatedProduct = await Product.findByIdAndUpdate(id, updateObj, {
      new: true,
    });

    ctx.body = updatedProduct;
  } catch (err) {
    console.error("Error updating product:", err);
    ctx.status = 500;
    ctx.body = { error: "An error occurred while updating the product" };
  }
});
